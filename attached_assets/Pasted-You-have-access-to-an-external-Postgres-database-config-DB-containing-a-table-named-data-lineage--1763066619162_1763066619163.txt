You have access to an external Postgres database (config DB) containing a table named data_lineage.
Below is the list of columns and their meanings:

lineage_id â€“ Unique auto-generated identifier for each lineage record.
lineage_type â€“ Type of mapping: straight pass, derived, rename, new column.
application_name â€“ Name of the application or pipeline generating the lineage.
config_key â€“ Reference key to the ETL/ELT configuration/mapping definition.
data_element_id â€“ Business data element identifier linked to glossary/dictionary.
source_layer â€“ Logical layer where the source resides.
source_system â€“ Source system name.
source_schema_name â€“ Source schema name.
source_table_name â€“ Source table name.
source_column â€“ Source column name.
source_datatype â€“ Source column data type.
target_layer â€“ Logical layer where the target resides.
target_system â€“ Target system name.
target_schema_name â€“ Target schema name.
target_table_name â€“ Target table name.
target_column â€“ Target column name.
target_datatype â€“ Target column data type.
transformation_logic â€“ SQL or transformation expression.
filter_condition â€“ WHERE/filter logic applied during ETL.
update_at â€“ Last updated timestamp.
created_by â€“ Creator of the lineage record.
created_ts â€“ Created timestamp.
effective_date â€“ Lineage valid start.
expiry_date â€“ Lineage valid end.
active_flag â€“ Y/N active indicator.

âœ… TASK: Build a New Page Called â€œData Lineageâ€

This page must display table-level and attribute-level lineage with full forward & backward trace.

ğŸ›ï¸ Filters Required

All filters should dynamically refresh the lineage results and the lineage diagram.

1. Source Application Name

Join logic (updated):

Use config_key from data_lineage

Join to config_table to retrieve source_application_id

Join to application_config on application_id

Display application name in filter dropdown

2. Target Application Name

Join logic (updated):

Use config_key from data_lineage

Join to config_table to retrieve target_application_id

Join to application_config on application_id

Display application name in filter dropdown

3. Source Schema Name
4. Target Schema Name
5. Source Layer
6. Target Layer
7. Source Table Name
8. Target Table Name
9. Global Search Box

Search by:

Table name

Attribute/column name
(Source or Target)

ğŸ“Š Lineage Diagram Requirements
Layout

Source â†’ Target (left â†’ right)

Display layers in order: Raw â†’ Bronze â†’ Silver â†’ Gold â†’ Mart

Show directional arrows clearly

Support multi-hop lineage across layers

Node Types

Tables

Columns/attributes

Derived columns

Renamed columns

New columns

Each node must show tooltips for:

Data type

Transformation logic (if applicable)

Lineage type badge

Edge Features

Show mapping type

Show transformation logic preview

Show filter condition preview

ğŸ” LINEAGE TRAVERSAL LOGIC (Node.js In-Memory Graph)

All lineage rows are fetched once and placed into an in-memory graph for fast traversal.

When a user selects a table or column:
1. Backward (Upstream) Trace

Find all records where selected table/column appears as target_*.
Continue recursively until no more upstream nodes exist.

2. Forward (Downstream) Trace

Find all records where selected table/column appears as source_*.
Continue recursively until no further targets exist.

3. Derived Column Handling

For lineage_type = derived column:

Support multiple-source â†’ single-target

Support single-source â†’ multiple-derived

Expand all branches in the lineage graph

4. Rename Column Handling

Treat renamed columns as equivalent while traversing.

5. New Column Handling

No upstream lineage

Still support downstream lineage

âš™ï¸ Node.js Optimized Enhancements
1. Build In-Memory Lineage Graph

Use indexes such as:

sourceIndex: { "<schema>.<table>.<column>": [...] }
targetIndex: { "<schema>.<table>.<column>": [...] }
tableIndex:  { "<schema>.<table>": [...] }


This ensures extremely fast lineage traversal.

2. Graph Caching

Cache the lineage graph to avoid reprocessing on each load.

3. Layer Clustering

Group all nodes visually by:

Layer (Raw, Bronze, Silver, Gold, Mart)

Application

4. Multi-Path Handling

If multiple lineage branches exist:

Show all

Provide Â± expand/collapse

5. Incomplete Lineage Handling

If lineage breaks:

Display "Unknown Source" or "Unknown Target" nodes

Prevent diagram breaks

6. Drill-Down Panel

Click a node â†’ show detailed metadata:

Source/target columns

Data types

Transformation logic

Effective/expiry dates

Lineage type

7. View Modes

Provide a toggle:

Table-level lineage

Column-level lineage

Combined view

8. Export Tools

Allow export of:

Diagram (PNG/SVG)

Lineage data (CSV/Excel)

9. Error-Tolerant UI

Show structured messages for:

No lineage found

Invalid filter

Missing application-config join

Missing config_key mapping

ğŸ§© Final Expected Output

The â€œData Lineageâ€ page must:

Load all lineage rows once into memory

Build an efficient lineage graph

Support backward and forward traversal

Visualize lineage across multiple layers

Handle derived/rename/new column logic

Include all specified filters

Render a clean, interactive diagram

Provide drilldown details for experts

Operate fast and handle missing/incomplete lineage gracefully